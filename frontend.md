# Frontend Application

This directory contains the source code for the frontend application. The deployed site can be found [here](https://felix-seifert.github.io/serverless-on-heroku/frontend/).

## Files

-   `index.html`: main HTML file for interaction with Heroku
-   `styles.css`: simple stylings for making things more pretty
-   `heroku.js`: code for communicating with Heroku and interpreting result

The import of the CSS and the JavaScript into the HTML file has to happen in the head section of `index.html`.

```html
...
<head>
    ...
    <link rel="stylesheet" href="./styles.css" />
    <script type="text/javascript" src="./heroku.js"></script>
    ...
</head>
...
```

## Communicating With Heroku API

In the `index.html` file, we have three different input fields for: the Heroku project ID of the project we want to communicate with, the Heroku API key and a name which will be the argument for the function on the one-off dyno. The Heroku API key should be generated from an account with write privilege for the specified Heroku project.

```html
<input type="text" placeholder="Your Heroku app" id="herokuApp" />
<input type="text" placeholder="Your Heroku API key" id="herokuApiKey" />
<input type="text" placeholder="Your name" id="name" />
<button onclick="startDyno()">Start dyno</button>
```

When pressing the displayed start button, the function `startDyno`, defined in `heroku.js`, will be triggered. This function will read the values from the input fields by using `document.getElementById(elementId: string).value`. With these values, we create a POST request to the url `https://api.heroku.com/apps/<HEORKU_APP_ID>/dynos` containing the following data:

```json
{
    "command": "serverless",
    "env": {
        "NAME": "<NAME>"
    }
}
```

This will initialize the task `serverless` specified in our `Procfile` in a one-off dyno with the environment variable `NAME` set to the name we supplied in the form.

```js
/**
 * Start Dyno and get log stream generated by dyno
 */
const startDyno = () => {
    setError();
    setLog();

    const herokuApp = document.getElementById("herokuApp").value;
    const herokuApiKey = document.getElementById("herokuApiKey").value;
    const name = document.getElementById("name").value;

    makeHerokuRequest("/dynos", herokuApp, herokuApiKey, "POST", {
        command: "serverless",
        env: {
            NAME: name,
        },
    }).then(async (res) => {
        const content = await res.json();
        if (res.ok) {
            getLogStream(content.name, herokuApp, herokuApiKey);
        } else {
            setError(content.message);
        }
    });
};
```

The JSON response from the request will include the key `name`, which has the value of the name of the created dyno. To get the log stream for the created dyno, we make a `POST` request to the url `https://api.heroku.com/apps/<HEROKU_APP_ID>/log-sessions` containing the following data.

```json
{
    "dyno": "<DYNO_NAME>",
    "tail": true
}
```

`<DYNO_NAME>` is here the dyno name returned from initializing the one-off dyno. In this request we also include the `tail` key and set the value to `true`. This results in streaming the output of the dyno as it is executing.

```js
/**
 * Get log stream from heroku
 * @param {string} dyno  Name of created dyno
 * @param {string} herokuApp  Name of Heroku app
 * @param {string} apiToken  API token used to authenticate
 */
const getLogStream = (dyno, herokuApp, apiToken) => {
    makeHerokuRequest("/log-sessions", herokuApp, apiToken, "POST", {
        dyno,
        tail: true,
    }).then(async (res) => {
        const content = await res.json();
        if (res.ok) {
            fetch(content.logplex_url)
                .then((response) => response.body.getReader())
                .then(readStream);
        } else {
            setError(content.message);
        }
    });
};
```

The JSON response from this request will include a key `logplex_url`, which is the url we can use to fetch the log stream. We can fetch it simply by using the `fetch` library and extract the stream reader by calling the method `getReader()` on the response body.

```js
fetch(content.logplex_url)
    .then((response) => response.body.getReader())
    .then(readStream);
```

To read the stream and update the webpage, we run the method `read` of the reader which returns a promise that is resolved when either more data is available or the stream is closed.

```js
/**
 * Read stream and update output visible to user
 * @param {ReadableStreamReader<Uint8Array>} reader
 */
const readStream = (reader) => {
    const log = document.getElementById("output");
    reader.read().then(({ done, value }) => {
        if (done) {
            console.log("Stream complete");
            return;
        }
        setLog(log.textContent + decoder.decode(value));

        return readStream(reader);
    });
};
```

## Setting Log and Error

To set the log output of our dyno execution, we can simply get the DOM element by using `document.getElementId` and update the text content.

```html
<code id="output"></code>
```

```js
/**
 * Set logging result to display to user
 * @param {string} message  Logging string, default to ""
 */
const setLog = (message = "") => {
    const log = document.getElementById("output");
    log.textContent = message;
};
```

In a similar manner, we update the error output if something goes wrong in the process.

```html
<code id="error"></code>
```

```js
/**
 * Set error message to display to user
 * @param {string} message  Error message, defaults to ""
 */
const setError = (message = "") => {
    const error = document.getElementById("error");
    error.textContent = message;
};
```

## Security Considerations

Since Heroku does not have the functionality to scope your API token to only be able to initialize one-off dynos, it is advised to **never** push these tokens to GitHub or host them statically on the website. Otherwise, this could give hackers the opportunity to get write access to your Heroku project. This is why we require users to input their API token when using this frontend application.
